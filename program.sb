' WRO 2022 middle by rocot(from rus. рокот)

' ! RULES !
' * We mustn't use transliteration
' * We mustn't comment smth like "Roma Loh"
' * We must use variables for motors ports

' TODO:
' * Line (completed)
' * Count obstacle_deg variable value (completed)
' * Use forward odds through all program
' * Create comments for each grab function

' Environment variables
left_motor = "A"
right_motor = "B"
motors = left_motor + right_motor
left_forward = -1
right_forward = 1
left_scaner = 4
right_scaner = 3
left_line = 1
right_line = 2
grabber_motor = "C"
water_motor = "D"
basic_line_power = 40
black = 15
white = 30
basic_power = 40
small_power = 30
very_small_power = 10
reset_forward_deg = 130
deg = 0
' Degrees, that robot has to pass before finding the line by sensor's values
obstacle_deg = 1000

' Odds
p = 0.5
d = 2

' Necessary variables
LastError = 0
integral = 0

' Switch sensors to the correct mode
Sensor.SetMode(left_line, 0)
Sensor.SetMode(right_line, 0)

' Kick one cube of water
Sub kick_water
  Motor.Move(water_motor, 50, 180, "True")
  Motor.Wait(water_motor)
EndSub

' Main line function (one iteration of other lines)
Sub line
  NowError = Sensor.ReadPercent(right_line) - Sensor.ReadPercent(left_line)
  dif = LastError - NowError
  integral = (integral + NowError) / 10
  derivative = NowError - LastError
  up = ((NowError*p) + (integral*d))
  Motor.StartPower(right_motor, right_forward * (90 + up))
  Motor.StartPower(left_motor, left_forward * (90 - up))
  LastError = NowError
EndSub

' Endless line ride
Sub endless_line
  While "True"
    line()
  EndWhile
EndSub

' Go by line to a crossroad
Sub line_crossroad
  While Sensor.ReadPercent(left_line) > black Or Sensor.ReadPercent(right_line) > black
    line()
  EndWhile
  Motor.Stop(motors, "True")
EndSub

Sub line_right_crossroad
  While Sensor.ReadPercent(right_line) > black
    line()
  EndWhile
  Motor.Stop(motors, "True")
EndSub

Sub obstacle_test
  Motor.Start(left_motor, left_forward * 30)
  Motor.Start(right_motor, right_forward * 30)
  Program.Delay(5000)
  Motor.Stop(motors, "True")
EndSub

Sub turn_right_by_line
  Motor.MoveSync(motors, left_forward * very_small_power, right_forward * -1 * very_small_power, 100, "False")
  Motor.Wait(motors)
  Motor.StartSync(motors, left_forward * very_small_power, right_forward * -1 * very_small_power)
  While Sensor.ReadPercent(left_line) < black
  EndWhile
  While Sensor.ReadPercent(left_line) > black
  EndWhile
  Motor.Stop(motors, "True")
EndSub

Sub turn_left_by_line
  Motor.MoveSync(motors, left_forward * very_small_power * -1, right_forward * very_small_power, 100, "False")
  Motor.Wait(motors)
  Motor.StartSync(motors, left_forward * -1 * very_small_power, right_forward * very_small_power)
  While Sensor.ReadPercent(right_line) < black
  EndWhile
  While Sensor.ReadPercent(right_line) > black
  EndWhile
  Motor.Stop(motors, "True")
EndSub

Sub reset_forward
  Motor.MoveSync(motors, left_forward * small_power, right_forward * small_power, reset_forward_deg, "True")
  Motor.Wait(motors)
  Motor.Wait(motors)
EndSub

Sub line_degrees
  Motor.ResetCount(right_motor)
  While Motor.GetCount(right_motor) < deg
    line()
  EndWhile
EndSub

Sub start_through_obstacle
  ' I expect that robot stands backwards
  Motor.ResetCount(left_motor)
  Motor.Start(left_motor, left_forward * basic_power * -1)
  Motor.Start(right_motor, right_forward* basic_power * -1)
  While Motor.GetCount(left_motor) < obstacle_deg
  EndWhile
  Motor.Start(left_motor, left_forward * small_power * -1)
  Motor.Start(right_motor, right_forward* small_power * -1)
  While Sensor.ReadPercent(left_line) < white
  EndWhile
  While Sensor.ReadPercent(left_line) > black
  EndWhile
  Motor.Stop(motors, "True")
EndSub

' Start from right start zone
Sub start_from_right_position
  start_through_obstacle()
  Program.Delay(100)
  reset_forward()
  turn_right_by_line()
  line_crossroad()
  reset_forward()
  line_right_crossroad()
  reset_forward()
  turn_right_by_line()
  deg = 650
  line_degrees()
EndSub

' Start from left start zone
Sub start_from_left_position
  start_through_obstacle()
  reset_forward()
  turn_left_by_line()
  turn_left_by_line()
  deg = 650
  line_degrees()
EndSub

' Lift the chemical
Sub Grab
  Motor.Start(grabber_motor, -90)
  Program.Delay(300)
  Motor.Stop(grabber_motor, "True")
EndSub

' Grab chemical from right forward position (distinct with forward right)
Sub grab_rf
  Motor.Move(left_motor, 10 * left_forward, 235, "True")
  Grab()
  Motor.Move(left_motor, -10 * left_forward, 235, "True")
EndSub

' Grab chemical from forward left position
Sub grab_fl
  Motor.MoveSync(motors, -20 * left_forward, 20 * right_forward, 50, "True")
  Motor.MoveSync(motors, 20 * left_forward, 20 * right_forward, 150, "True")
  Grab()
  Motor.MoveSync(motors, -20 * left_forward, -20 * right_forward, 150, "True")
  Motor.MoveSync(motors, 20 * left_forward, -20 * right_forward, 50, "True")
EndSub

' Grab chemical from forward right position (distinct with right forward)
Sub grab_fr
  Motor.MoveSync(motors, 20 * left_forward, -20 * right_forward, 50, "True")
  Motor.MoveSync(motors, 20 * left_forward, 20 * right_forward, 150 ,"True")
  Grab()
  Motor.MoveSync(motors, -20 * left_forward, -20 * right_forward, 150, "True")
  Motor.MoveSync(motors, -20 * left_forward, 20 * right_forward, 50, "True")
EndSub

' Grab chemical from right back position
Sub grab_rb
  delay = 100
  Motor.MoveSync(motors, 30 * left_forward, 30 * right_forward, 100, "True")
  Program.Delay(delay)
  Motor.move(right_motor, -90 * right_forward, 400, "True")
  Program.Delay(delay)
  Motor.MoveSync(motors, -20 * left_forward, -20 * right_forward, 50, "True")
  Program.Delay(delay)
  Motor.Move(left_motor, 10 * left_forward, 170, "True")
  Motor.Move(right_motor, 10 * right_forward, 170, "True")
  Motor.MoveSync(motors, 10 * left_forward, 10 * right_forward, 20, "True")
  Grab()
  Motor.MoveSync(motors, -10 * left_forward, -10 * right_forward, 20, "True")
  Motor.Move(right_motor, -10 * right_forward, 170, "True")
  Motor.Move(left_motor, -10 * left_forward, 170, "True")
  Program.Delay(delay)
  Motor.MoveSync(motors, 20 * left_forward, 20 * right_forward, 20, "True")
  Program.Delay(delay)
  Motor.move(right_motor, 90 * right_forward, 400, "True")
  Program.Delay(delay)
  Motor.MoveSync(motors, -30 * left_forward, -30 * right_forward, 130, "True")
EndSub

' Actual program
